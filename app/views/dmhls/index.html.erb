<%= stylesheet_link_tag "dmhls" %>
<% @last_modify_date = File.open(__FILE__).mtime.strftime("%Y-%m-%d %H:%M:%S " + File.open(__FILE__).mtime.zone) %>
<div>
  <h1 style=" font-weight: bold;">
    DMHLS
  </h1>
  <h2 style="font-weight: bold;">
    Direct-Mapping High-Level Synthesis
  </h2>
  <hr/>
  <h3>Introduction</h3>
  <p>
    <em>High Level Synthesis</em> (HLS) has been a research topic for some three decades. Since late 1980s,
    there has been continuous effort for automating the process of RTL design by generating the
    HDL code such as Verilog HDL and VHDL automatically. Previously, HLS focused on how to optimize the
    resource usage and/or the delay for the whole work, and treat it as an optimization problem.
    Thus, some mathematical optimization models were proposed to solve the HLS problem. The earliest one of
    these models might be the <em><a href="http://www.cs.tufts.edu/~soha/cadathlon03/refs/ILP_SCHED_Hwang_TCAD91.pdf">
    Integer Linear Programming</a></em> (ILP) model, which is able to get the
    optimal solution subject to delay constraints or resource constraints. However, the ILP model is very slow
    to get solution.
    <a href="http://cadlab.cs.ucla.edu/~cong/papers/28.1-cong.pdf">SDC (System of Difference Constraints) </a>
    is another model used to solve this optimization problem,
    which is faster than ILP model, but still much slower than the software compiler.
  </p>
  <p>
    Recent HLS research also focuses on loop optimization,
    an existing topic mainly for software compiler optimization.
    The problem is that loop structure is never necessary for either
    programming or hardware description,
    but only especially suitable for sequential programming of CPU.
    It is well-known that the <a href="https://en.wikipedia.org/wiki/Functional_programming#Recursion">
    functional programming languages prefer recursion to loop</a>,
    and often replace loops with recursive functions with tail recursion optimization.
    Since High-Level Synthesis is targeting hardware, which is intrinsically parallel,
    loops might not be a proper structure for parallel programming or description of
    intrinscally parallel hardware.
  </p>
  <p>
    Loop optimization has another problem: it changes the architecture too much.
    <a href="https://en.wikipedia.org/wiki/Loop_unrolling">Loop unrolling</a>,
    for example, a common loop optimization technique -- if the loop is running on a CPU --
    only reduces the execution time by removing the instructions used for loop bounds checking
    and some other trivial calculations such as pointer increment.
    The asymptotic time complexity for the program is still the same.
    However, if the loop unrolling is used for high-level synthesis,
    it actually copys the loop body.
    The asymptotic space or area will change from constant space to linear space,
    if the loop is fully unrolled.
    Although the execution time for the loop also drops from linear time to constant time,
    the space or area is crucial for hardware to the same extent as the execution time.

  </p>

  <p>
    <em>Direct-Mapping High-Level Synthesis</em> (DMHLS)
    is an novel framework for <em>High Level Synthesis</em>,
    which is fast, aiming to achieve the speed of software compiler for microprocessors.
    Rather than formulating HLS as mainly an optimization problem, DMHLS considers direct mapping in the first place,
    trying to eable accurate and clear architecture descriptions through high level languages such as C programming
    language, without automated resource sharing and loop optimizations that changes the architecture too much or
    "obscures the architecture"<a href="http://csg.csail.mit.edu/6.S078/6_S078_2012_www/resources/bsv_by_example.pdf">
    (BSV by Example, p12)</a>.
    DMHLS starts from <a href="http://llvm.org/">LLVM </a>Intermediate Representations (LLVM IR)
    and generate Verilog HDL codes. LLVM IR is a typical
    <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static-Single Assignment (SSA)</a>
    form of intermediate representation. Although DMHLS only supports LLVM IR currently,
    the techniques underneath the framework should
    works fine for any SSA form of intermediate representations</p>



  <h4>
    Structure Recursion
  </h4>
  <p>
    Unfortunately, few existing high-level synthesis framework support recursion.
    The difficulty is that if the HLS tool inlines all the functions calls,
    the size of the synthesized circuit cannot be determined statically (at compile time)
    for recursive function calls with runtime arguments;
    while if the HLS tool doesn't inline functions, a <a href="https://en.wikipedia.org/wiki/Call_stack">
    call stack</a> is required to implement function call. However, large continuous memory storage might not
    always be present for hardware. For example, in FPGA, there are many distributed memory elements,
    but the size of random access memory is limited.
    This difficulty causes many HLS tools completely disable recursion.
  </p><!--
  <p>
    Despite the difficulty of recursive function calls, recursion is still very useful for high-level synthesis.
    Noting that recursive function is only one form of recursison. Originally, it stems from recursive definition

  </p>-->

  <p>
    <!--<a href="https://github.com/li3939108/dmhls/archive/master.zip">Download</a><br/>-->
    <a href="https://github.com/li3939108/dmhls">Github Repository</a>
  </p>
  <hr/>
  <p style="text-align: right;">
    <%= @last_modify_date %><br/>
    by Chaofan Li
  </p>
</div>
